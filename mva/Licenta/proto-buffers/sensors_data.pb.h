// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors_data.proto

#ifndef PROTOBUF_sensors_5fdata_2eproto__INCLUDED
#define PROTOBUF_sensors_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_sensors_5fdata_2eproto();
void protobuf_AssignDesc_sensors_5fdata_2eproto();
void protobuf_ShutdownFile_sensors_5fdata_2eproto();

class ItemPair;
class DataType;
class MotherboardData;
class CpuData;
class RAMData;
class DiskData;
class GPUData;
class SensorsData;

// ===================================================================

class ItemPair : public ::google::protobuf::MessageLite {
 public:
  ItemPair();
  virtual ~ItemPair();

  ItemPair(const ItemPair& from);

  inline ItemPair& operator=(const ItemPair& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemPair& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemPair* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemPair* other);

  // implements Message ----------------------------------------------

  ItemPair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemPair& from);
  void MergeFrom(const ItemPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:ItemPair)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static ItemPair* default_instance_;
};
// -------------------------------------------------------------------

class DataType : public ::google::protobuf::MessageLite {
 public:
  DataType();
  virtual ~DataType();

  DataType(const DataType& from);

  inline DataType& operator=(const DataType& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataType& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataType* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataType* other);

  // implements Message ----------------------------------------------

  DataType* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataType& from);
  void MergeFrom(const DataType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dataName = 1;
  inline bool has_dataname() const;
  inline void clear_dataname();
  static const int kDataNameFieldNumber = 1;
  inline const ::std::string& dataname() const;
  inline void set_dataname(const ::std::string& value);
  inline void set_dataname(const char* value);
  inline void set_dataname(const char* value, size_t size);
  inline ::std::string* mutable_dataname();
  inline ::std::string* release_dataname();
  inline void set_allocated_dataname(::std::string* dataname);

  // repeated .ItemPair dataValue = 2;
  inline int datavalue_size() const;
  inline void clear_datavalue();
  static const int kDataValueFieldNumber = 2;
  inline const ::ItemPair& datavalue(int index) const;
  inline ::ItemPair* mutable_datavalue(int index);
  inline ::ItemPair* add_datavalue();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemPair >&
      datavalue() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemPair >*
      mutable_datavalue();

  // @@protoc_insertion_point(class_scope:DataType)
 private:
  inline void set_has_dataname();
  inline void clear_has_dataname();

  ::std::string* dataname_;
  ::google::protobuf::RepeatedPtrField< ::ItemPair > datavalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static DataType* default_instance_;
};
// -------------------------------------------------------------------

class MotherboardData : public ::google::protobuf::MessageLite {
 public:
  MotherboardData();
  virtual ~MotherboardData();

  MotherboardData(const MotherboardData& from);

  inline MotherboardData& operator=(const MotherboardData& from) {
    CopyFrom(from);
    return *this;
  }

  static const MotherboardData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MotherboardData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MotherboardData* other);

  // implements Message ----------------------------------------------

  MotherboardData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MotherboardData& from);
  void MergeFrom(const MotherboardData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .DataType data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::DataType& data(int index) const;
  inline ::DataType* mutable_data(int index);
  inline ::DataType* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataType >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:MotherboardData)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::DataType > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static MotherboardData* default_instance_;
};
// -------------------------------------------------------------------

class CpuData : public ::google::protobuf::MessageLite {
 public:
  CpuData();
  virtual ~CpuData();

  CpuData(const CpuData& from);

  inline CpuData& operator=(const CpuData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CpuData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CpuData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CpuData* other);

  // implements Message ----------------------------------------------

  CpuData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CpuData& from);
  void MergeFrom(const CpuData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .DataType data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::DataType& data(int index) const;
  inline ::DataType* mutable_data(int index);
  inline ::DataType* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataType >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:CpuData)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::DataType > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static CpuData* default_instance_;
};
// -------------------------------------------------------------------

class RAMData : public ::google::protobuf::MessageLite {
 public:
  RAMData();
  virtual ~RAMData();

  RAMData(const RAMData& from);

  inline RAMData& operator=(const RAMData& from) {
    CopyFrom(from);
    return *this;
  }

  static const RAMData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RAMData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RAMData* other);

  // implements Message ----------------------------------------------

  RAMData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RAMData& from);
  void MergeFrom(const RAMData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .DataType data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::DataType& data(int index) const;
  inline ::DataType* mutable_data(int index);
  inline ::DataType* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataType >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:RAMData)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::DataType > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static RAMData* default_instance_;
};
// -------------------------------------------------------------------

class DiskData : public ::google::protobuf::MessageLite {
 public:
  DiskData();
  virtual ~DiskData();

  DiskData(const DiskData& from);

  inline DiskData& operator=(const DiskData& from) {
    CopyFrom(from);
    return *this;
  }

  static const DiskData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DiskData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DiskData* other);

  // implements Message ----------------------------------------------

  DiskData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DiskData& from);
  void MergeFrom(const DiskData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .DataType data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::DataType& data(int index) const;
  inline ::DataType* mutable_data(int index);
  inline ::DataType* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataType >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:DiskData)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::DataType > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static DiskData* default_instance_;
};
// -------------------------------------------------------------------

class GPUData : public ::google::protobuf::MessageLite {
 public:
  GPUData();
  virtual ~GPUData();

  GPUData(const GPUData& from);

  inline GPUData& operator=(const GPUData& from) {
    CopyFrom(from);
    return *this;
  }

  static const GPUData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GPUData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GPUData* other);

  // implements Message ----------------------------------------------

  GPUData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GPUData& from);
  void MergeFrom(const GPUData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .DataType data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::DataType& data(int index) const;
  inline ::DataType* mutable_data(int index);
  inline ::DataType* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::DataType >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:GPUData)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::DataType > data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static GPUData* default_instance_;
};
// -------------------------------------------------------------------

class SensorsData : public ::google::protobuf::MessageLite {
 public:
  SensorsData();
  virtual ~SensorsData();

  SensorsData(const SensorsData& from);

  inline SensorsData& operator=(const SensorsData& from) {
    CopyFrom(from);
    return *this;
  }

  static const SensorsData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SensorsData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SensorsData* other);

  // implements Message ----------------------------------------------

  SensorsData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SensorsData& from);
  void MergeFrom(const SensorsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MotherboardData mbData = 1;
  inline bool has_mbdata() const;
  inline void clear_mbdata();
  static const int kMbDataFieldNumber = 1;
  inline const ::MotherboardData& mbdata() const;
  inline ::MotherboardData* mutable_mbdata();
  inline ::MotherboardData* release_mbdata();
  inline void set_allocated_mbdata(::MotherboardData* mbdata);

  // optional .CpuData cpuData = 2;
  inline bool has_cpudata() const;
  inline void clear_cpudata();
  static const int kCpuDataFieldNumber = 2;
  inline const ::CpuData& cpudata() const;
  inline ::CpuData* mutable_cpudata();
  inline ::CpuData* release_cpudata();
  inline void set_allocated_cpudata(::CpuData* cpudata);

  // optional .RAMData ramData = 3;
  inline bool has_ramdata() const;
  inline void clear_ramdata();
  static const int kRamDataFieldNumber = 3;
  inline const ::RAMData& ramdata() const;
  inline ::RAMData* mutable_ramdata();
  inline ::RAMData* release_ramdata();
  inline void set_allocated_ramdata(::RAMData* ramdata);

  // optional .DiskData diskData = 4;
  inline bool has_diskdata() const;
  inline void clear_diskdata();
  static const int kDiskDataFieldNumber = 4;
  inline const ::DiskData& diskdata() const;
  inline ::DiskData* mutable_diskdata();
  inline ::DiskData* release_diskdata();
  inline void set_allocated_diskdata(::DiskData* diskdata);

  // optional .GPUData gpuData = 5;
  inline bool has_gpudata() const;
  inline void clear_gpudata();
  static const int kGpuDataFieldNumber = 5;
  inline const ::GPUData& gpudata() const;
  inline ::GPUData* mutable_gpudata();
  inline ::GPUData* release_gpudata();
  inline void set_allocated_gpudata(::GPUData* gpudata);

  // @@protoc_insertion_point(class_scope:SensorsData)
 private:
  inline void set_has_mbdata();
  inline void clear_has_mbdata();
  inline void set_has_cpudata();
  inline void clear_has_cpudata();
  inline void set_has_ramdata();
  inline void clear_has_ramdata();
  inline void set_has_diskdata();
  inline void clear_has_diskdata();
  inline void set_has_gpudata();
  inline void clear_has_gpudata();

  ::MotherboardData* mbdata_;
  ::CpuData* cpudata_;
  ::RAMData* ramdata_;
  ::DiskData* diskdata_;
  ::GPUData* gpudata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_sensors_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_sensors_5fdata_2eproto();
  friend void protobuf_ShutdownFile_sensors_5fdata_2eproto();

  void InitAsDefaultInstance();
  static SensorsData* default_instance_;
};
// ===================================================================


// ===================================================================

// ItemPair

// required string name = 1;
inline bool ItemPair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemPair::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemPair::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemPair::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ItemPair::name() const {
  return *name_;
}
inline void ItemPair::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ItemPair::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ItemPair::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemPair::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ItemPair::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ItemPair::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool ItemPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemPair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemPair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ItemPair::value() const {
  return *value_;
}
inline void ItemPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ItemPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ItemPair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ItemPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ItemPair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DataType

// required string dataName = 1;
inline bool DataType::has_dataname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataType::set_has_dataname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataType::clear_has_dataname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataType::clear_dataname() {
  if (dataname_ != &::google::protobuf::internal::kEmptyString) {
    dataname_->clear();
  }
  clear_has_dataname();
}
inline const ::std::string& DataType::dataname() const {
  return *dataname_;
}
inline void DataType::set_dataname(const ::std::string& value) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::kEmptyString) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(value);
}
inline void DataType::set_dataname(const char* value) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::kEmptyString) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(value);
}
inline void DataType::set_dataname(const char* value, size_t size) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::kEmptyString) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataType::mutable_dataname() {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::kEmptyString) {
    dataname_ = new ::std::string;
  }
  return dataname_;
}
inline ::std::string* DataType::release_dataname() {
  clear_has_dataname();
  if (dataname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dataname_;
    dataname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataType::set_allocated_dataname(::std::string* dataname) {
  if (dataname_ != &::google::protobuf::internal::kEmptyString) {
    delete dataname_;
  }
  if (dataname) {
    set_has_dataname();
    dataname_ = dataname;
  } else {
    clear_has_dataname();
    dataname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ItemPair dataValue = 2;
inline int DataType::datavalue_size() const {
  return datavalue_.size();
}
inline void DataType::clear_datavalue() {
  datavalue_.Clear();
}
inline const ::ItemPair& DataType::datavalue(int index) const {
  return datavalue_.Get(index);
}
inline ::ItemPair* DataType::mutable_datavalue(int index) {
  return datavalue_.Mutable(index);
}
inline ::ItemPair* DataType::add_datavalue() {
  return datavalue_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemPair >&
DataType::datavalue() const {
  return datavalue_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemPair >*
DataType::mutable_datavalue() {
  return &datavalue_;
}

// -------------------------------------------------------------------

// MotherboardData

// required string name = 1;
inline bool MotherboardData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotherboardData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotherboardData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotherboardData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MotherboardData::name() const {
  return *name_;
}
inline void MotherboardData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MotherboardData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MotherboardData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MotherboardData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MotherboardData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MotherboardData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DataType data = 2;
inline int MotherboardData::data_size() const {
  return data_.size();
}
inline void MotherboardData::clear_data() {
  data_.Clear();
}
inline const ::DataType& MotherboardData::data(int index) const {
  return data_.Get(index);
}
inline ::DataType* MotherboardData::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::DataType* MotherboardData::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
MotherboardData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataType >*
MotherboardData::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// CpuData

// required string name = 1;
inline bool CpuData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpuData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CpuData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CpuData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CpuData::name() const {
  return *name_;
}
inline void CpuData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CpuData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CpuData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpuData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CpuData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpuData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DataType data = 2;
inline int CpuData::data_size() const {
  return data_.size();
}
inline void CpuData::clear_data() {
  data_.Clear();
}
inline const ::DataType& CpuData::data(int index) const {
  return data_.Get(index);
}
inline ::DataType* CpuData::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::DataType* CpuData::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
CpuData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataType >*
CpuData::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// RAMData

// required string name = 1;
inline bool RAMData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAMData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAMData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAMData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RAMData::name() const {
  return *name_;
}
inline void RAMData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RAMData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RAMData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RAMData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RAMData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RAMData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DataType data = 2;
inline int RAMData::data_size() const {
  return data_.size();
}
inline void RAMData::clear_data() {
  data_.Clear();
}
inline const ::DataType& RAMData::data(int index) const {
  return data_.Get(index);
}
inline ::DataType* RAMData::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::DataType* RAMData::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
RAMData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataType >*
RAMData::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// DiskData

// required string name = 1;
inline bool DiskData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DiskData::name() const {
  return *name_;
}
inline void DiskData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DiskData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DiskData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiskData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DiskData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiskData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DataType data = 2;
inline int DiskData::data_size() const {
  return data_.size();
}
inline void DiskData::clear_data() {
  data_.Clear();
}
inline const ::DataType& DiskData::data(int index) const {
  return data_.Get(index);
}
inline ::DataType* DiskData::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::DataType* DiskData::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
DiskData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataType >*
DiskData::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// GPUData

// required string name = 1;
inline bool GPUData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPUData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPUData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPUData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GPUData::name() const {
  return *name_;
}
inline void GPUData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GPUData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GPUData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPUData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GPUData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPUData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DataType data = 2;
inline int GPUData::data_size() const {
  return data_.size();
}
inline void GPUData::clear_data() {
  data_.Clear();
}
inline const ::DataType& GPUData::data(int index) const {
  return data_.Get(index);
}
inline ::DataType* GPUData::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::DataType* GPUData::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DataType >&
GPUData::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::DataType >*
GPUData::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// SensorsData

// optional .MotherboardData mbData = 1;
inline bool SensorsData::has_mbdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorsData::set_has_mbdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorsData::clear_has_mbdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorsData::clear_mbdata() {
  if (mbdata_ != NULL) mbdata_->::MotherboardData::Clear();
  clear_has_mbdata();
}
inline const ::MotherboardData& SensorsData::mbdata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mbdata_ != NULL ? *mbdata_ : *default_instance().mbdata_;
#else
  return mbdata_ != NULL ? *mbdata_ : *default_instance_->mbdata_;
#endif
}
inline ::MotherboardData* SensorsData::mutable_mbdata() {
  set_has_mbdata();
  if (mbdata_ == NULL) mbdata_ = new ::MotherboardData;
  return mbdata_;
}
inline ::MotherboardData* SensorsData::release_mbdata() {
  clear_has_mbdata();
  ::MotherboardData* temp = mbdata_;
  mbdata_ = NULL;
  return temp;
}
inline void SensorsData::set_allocated_mbdata(::MotherboardData* mbdata) {
  delete mbdata_;
  mbdata_ = mbdata;
  if (mbdata) {
    set_has_mbdata();
  } else {
    clear_has_mbdata();
  }
}

// optional .CpuData cpuData = 2;
inline bool SensorsData::has_cpudata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorsData::set_has_cpudata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorsData::clear_has_cpudata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorsData::clear_cpudata() {
  if (cpudata_ != NULL) cpudata_->::CpuData::Clear();
  clear_has_cpudata();
}
inline const ::CpuData& SensorsData::cpudata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cpudata_ != NULL ? *cpudata_ : *default_instance().cpudata_;
#else
  return cpudata_ != NULL ? *cpudata_ : *default_instance_->cpudata_;
#endif
}
inline ::CpuData* SensorsData::mutable_cpudata() {
  set_has_cpudata();
  if (cpudata_ == NULL) cpudata_ = new ::CpuData;
  return cpudata_;
}
inline ::CpuData* SensorsData::release_cpudata() {
  clear_has_cpudata();
  ::CpuData* temp = cpudata_;
  cpudata_ = NULL;
  return temp;
}
inline void SensorsData::set_allocated_cpudata(::CpuData* cpudata) {
  delete cpudata_;
  cpudata_ = cpudata;
  if (cpudata) {
    set_has_cpudata();
  } else {
    clear_has_cpudata();
  }
}

// optional .RAMData ramData = 3;
inline bool SensorsData::has_ramdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorsData::set_has_ramdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorsData::clear_has_ramdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorsData::clear_ramdata() {
  if (ramdata_ != NULL) ramdata_->::RAMData::Clear();
  clear_has_ramdata();
}
inline const ::RAMData& SensorsData::ramdata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ramdata_ != NULL ? *ramdata_ : *default_instance().ramdata_;
#else
  return ramdata_ != NULL ? *ramdata_ : *default_instance_->ramdata_;
#endif
}
inline ::RAMData* SensorsData::mutable_ramdata() {
  set_has_ramdata();
  if (ramdata_ == NULL) ramdata_ = new ::RAMData;
  return ramdata_;
}
inline ::RAMData* SensorsData::release_ramdata() {
  clear_has_ramdata();
  ::RAMData* temp = ramdata_;
  ramdata_ = NULL;
  return temp;
}
inline void SensorsData::set_allocated_ramdata(::RAMData* ramdata) {
  delete ramdata_;
  ramdata_ = ramdata;
  if (ramdata) {
    set_has_ramdata();
  } else {
    clear_has_ramdata();
  }
}

// optional .DiskData diskData = 4;
inline bool SensorsData::has_diskdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorsData::set_has_diskdata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorsData::clear_has_diskdata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorsData::clear_diskdata() {
  if (diskdata_ != NULL) diskdata_->::DiskData::Clear();
  clear_has_diskdata();
}
inline const ::DiskData& SensorsData::diskdata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return diskdata_ != NULL ? *diskdata_ : *default_instance().diskdata_;
#else
  return diskdata_ != NULL ? *diskdata_ : *default_instance_->diskdata_;
#endif
}
inline ::DiskData* SensorsData::mutable_diskdata() {
  set_has_diskdata();
  if (diskdata_ == NULL) diskdata_ = new ::DiskData;
  return diskdata_;
}
inline ::DiskData* SensorsData::release_diskdata() {
  clear_has_diskdata();
  ::DiskData* temp = diskdata_;
  diskdata_ = NULL;
  return temp;
}
inline void SensorsData::set_allocated_diskdata(::DiskData* diskdata) {
  delete diskdata_;
  diskdata_ = diskdata;
  if (diskdata) {
    set_has_diskdata();
  } else {
    clear_has_diskdata();
  }
}

// optional .GPUData gpuData = 5;
inline bool SensorsData::has_gpudata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorsData::set_has_gpudata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorsData::clear_has_gpudata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorsData::clear_gpudata() {
  if (gpudata_ != NULL) gpudata_->::GPUData::Clear();
  clear_has_gpudata();
}
inline const ::GPUData& SensorsData::gpudata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpudata_ != NULL ? *gpudata_ : *default_instance().gpudata_;
#else
  return gpudata_ != NULL ? *gpudata_ : *default_instance_->gpudata_;
#endif
}
inline ::GPUData* SensorsData::mutable_gpudata() {
  set_has_gpudata();
  if (gpudata_ == NULL) gpudata_ = new ::GPUData;
  return gpudata_;
}
inline ::GPUData* SensorsData::release_gpudata() {
  clear_has_gpudata();
  ::GPUData* temp = gpudata_;
  gpudata_ = NULL;
  return temp;
}
inline void SensorsData::set_allocated_gpudata(::GPUData* gpudata) {
  delete gpudata_;
  gpudata_ = gpudata;
  if (gpudata) {
    set_has_gpudata();
  } else {
    clear_has_gpudata();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sensors_5fdata_2eproto__INCLUDED
