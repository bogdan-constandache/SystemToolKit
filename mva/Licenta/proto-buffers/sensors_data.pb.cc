// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors_data.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "sensors_data.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

void protobuf_ShutdownFile_sensors_5fdata_2eproto() {
  delete ItemPair::default_instance_;
  delete DataType::default_instance_;
  delete MotherboardData::default_instance_;
  delete CpuData::default_instance_;
  delete RAMData::default_instance_;
  delete DiskData::default_instance_;
  delete GPUData::default_instance_;
  delete SensorsData::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_sensors_5fdata_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_sensors_5fdata_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ItemPair::default_instance_ = new ItemPair();
  DataType::default_instance_ = new DataType();
  MotherboardData::default_instance_ = new MotherboardData();
  CpuData::default_instance_ = new CpuData();
  RAMData::default_instance_ = new RAMData();
  DiskData::default_instance_ = new DiskData();
  GPUData::default_instance_ = new GPUData();
  SensorsData::default_instance_ = new SensorsData();
  ItemPair::default_instance_->InitAsDefaultInstance();
  DataType::default_instance_->InitAsDefaultInstance();
  MotherboardData::default_instance_->InitAsDefaultInstance();
  CpuData::default_instance_->InitAsDefaultInstance();
  RAMData::default_instance_->InitAsDefaultInstance();
  DiskData::default_instance_->InitAsDefaultInstance();
  GPUData::default_instance_->InitAsDefaultInstance();
  SensorsData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_sensors_5fdata_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_sensors_5fdata_2eproto_once_);
void protobuf_AddDesc_sensors_5fdata_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_sensors_5fdata_2eproto_once_,
                 &protobuf_AddDesc_sensors_5fdata_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_sensors_5fdata_2eproto {
  StaticDescriptorInitializer_sensors_5fdata_2eproto() {
    protobuf_AddDesc_sensors_5fdata_2eproto();
  }
} static_descriptor_initializer_sensors_5fdata_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int ItemPair::kNameFieldNumber;
const int ItemPair::kValueFieldNumber;
#endif  // !_MSC_VER

ItemPair::ItemPair()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ItemPair::InitAsDefaultInstance() {
}

ItemPair::ItemPair(const ItemPair& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ItemPair::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemPair::~ItemPair() {
  SharedDtor();
}

void ItemPair::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ItemPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ItemPair& ItemPair::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

ItemPair* ItemPair::default_instance_ = NULL;

ItemPair* ItemPair::New() const {
  return new ItemPair;
}

void ItemPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ItemPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ItemPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }

}

int ItemPair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemPair::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ItemPair*>(&from));
}

void ItemPair::MergeFrom(const ItemPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ItemPair::CopyFrom(const ItemPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemPair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ItemPair::Swap(ItemPair* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ItemPair::GetTypeName() const {
  return "ItemPair";
}


// ===================================================================

#ifndef _MSC_VER
const int DataType::kDataNameFieldNumber;
const int DataType::kDataValueFieldNumber;
#endif  // !_MSC_VER

DataType::DataType()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataType::InitAsDefaultInstance() {
}

DataType::DataType(const DataType& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataType::SharedCtor() {
  _cached_size_ = 0;
  dataname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataType::~DataType() {
  SharedDtor();
}

void DataType::SharedDtor() {
  if (dataname_ != &::google::protobuf::internal::kEmptyString) {
    delete dataname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataType& DataType::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

DataType* DataType::default_instance_ = NULL;

DataType* DataType::New() const {
  return new DataType;
}

void DataType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dataname()) {
      if (dataname_ != &::google::protobuf::internal::kEmptyString) {
        dataname_->clear();
      }
    }
  }
  datavalue_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string dataName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dataname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dataValue;
        break;
      }

      // repeated .ItemPair dataValue = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dataValue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_datavalue()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dataValue;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string dataName = 1;
  if (has_dataname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->dataname(), output);
  }

  // repeated .ItemPair dataValue = 2;
  for (int i = 0; i < this->datavalue_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->datavalue(i), output);
  }

}

int DataType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string dataName = 1;
    if (has_dataname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dataname());
    }

  }
  // repeated .ItemPair dataValue = 2;
  total_size += 1 * this->datavalue_size();
  for (int i = 0; i < this->datavalue_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->datavalue(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataType::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataType*>(&from));
}

void DataType::MergeFrom(const DataType& from) {
  GOOGLE_CHECK_NE(&from, this);
  datavalue_.MergeFrom(from.datavalue_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dataname()) {
      set_dataname(from.dataname());
    }
  }
}

void DataType::CopyFrom(const DataType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < datavalue_size(); i++) {
    if (!this->datavalue(i).IsInitialized()) return false;
  }
  return true;
}

void DataType::Swap(DataType* other) {
  if (other != this) {
    std::swap(dataname_, other->dataname_);
    datavalue_.Swap(&other->datavalue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataType::GetTypeName() const {
  return "DataType";
}


// ===================================================================

#ifndef _MSC_VER
const int MotherboardData::kNameFieldNumber;
const int MotherboardData::kDataFieldNumber;
#endif  // !_MSC_VER

MotherboardData::MotherboardData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MotherboardData::InitAsDefaultInstance() {
}

MotherboardData::MotherboardData(const MotherboardData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MotherboardData::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MotherboardData::~MotherboardData() {
  SharedDtor();
}

void MotherboardData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MotherboardData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MotherboardData& MotherboardData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

MotherboardData* MotherboardData::default_instance_ = NULL;

MotherboardData* MotherboardData::New() const {
  return new MotherboardData;
}

void MotherboardData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MotherboardData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated .DataType data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MotherboardData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // repeated .DataType data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(i), output);
  }

}

int MotherboardData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .DataType data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MotherboardData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MotherboardData*>(&from));
}

void MotherboardData::MergeFrom(const MotherboardData& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void MotherboardData::CopyFrom(const MotherboardData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotherboardData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void MotherboardData::Swap(MotherboardData* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MotherboardData::GetTypeName() const {
  return "MotherboardData";
}


// ===================================================================

#ifndef _MSC_VER
const int CpuData::kNameFieldNumber;
const int CpuData::kDataFieldNumber;
#endif  // !_MSC_VER

CpuData::CpuData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CpuData::InitAsDefaultInstance() {
}

CpuData::CpuData(const CpuData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CpuData::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CpuData::~CpuData() {
  SharedDtor();
}

void CpuData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CpuData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CpuData& CpuData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

CpuData* CpuData::default_instance_ = NULL;

CpuData* CpuData::New() const {
  return new CpuData;
}

void CpuData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CpuData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated .DataType data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CpuData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // repeated .DataType data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(i), output);
  }

}

int CpuData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .DataType data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CpuData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CpuData*>(&from));
}

void CpuData::MergeFrom(const CpuData& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void CpuData::CopyFrom(const CpuData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CpuData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void CpuData::Swap(CpuData* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CpuData::GetTypeName() const {
  return "CpuData";
}


// ===================================================================

#ifndef _MSC_VER
const int RAMData::kNameFieldNumber;
const int RAMData::kDataFieldNumber;
#endif  // !_MSC_VER

RAMData::RAMData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RAMData::InitAsDefaultInstance() {
}

RAMData::RAMData(const RAMData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RAMData::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RAMData::~RAMData() {
  SharedDtor();
}

void RAMData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RAMData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RAMData& RAMData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

RAMData* RAMData::default_instance_ = NULL;

RAMData* RAMData::New() const {
  return new RAMData;
}

void RAMData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RAMData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated .DataType data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RAMData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // repeated .DataType data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(i), output);
  }

}

int RAMData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .DataType data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RAMData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RAMData*>(&from));
}

void RAMData::MergeFrom(const RAMData& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void RAMData::CopyFrom(const RAMData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RAMData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void RAMData::Swap(RAMData* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RAMData::GetTypeName() const {
  return "RAMData";
}


// ===================================================================

#ifndef _MSC_VER
const int DiskData::kNameFieldNumber;
const int DiskData::kDataFieldNumber;
#endif  // !_MSC_VER

DiskData::DiskData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DiskData::InitAsDefaultInstance() {
}

DiskData::DiskData(const DiskData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DiskData::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiskData::~DiskData() {
  SharedDtor();
}

void DiskData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DiskData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DiskData& DiskData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

DiskData* DiskData::default_instance_ = NULL;

DiskData* DiskData::New() const {
  return new DiskData;
}

void DiskData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DiskData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated .DataType data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DiskData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // repeated .DataType data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(i), output);
  }

}

int DiskData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .DataType data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiskData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DiskData*>(&from));
}

void DiskData::MergeFrom(const DiskData& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void DiskData::CopyFrom(const DiskData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiskData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void DiskData::Swap(DiskData* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DiskData::GetTypeName() const {
  return "DiskData";
}


// ===================================================================

#ifndef _MSC_VER
const int GPUData::kNameFieldNumber;
const int GPUData::kDataFieldNumber;
#endif  // !_MSC_VER

GPUData::GPUData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GPUData::InitAsDefaultInstance() {
}

GPUData::GPUData(const GPUData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GPUData::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPUData::~GPUData() {
  SharedDtor();
}

void GPUData::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GPUData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GPUData& GPUData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

GPUData* GPUData::default_instance_ = NULL;

GPUData* GPUData::New() const {
  return new GPUData;
}

void GPUData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GPUData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated .DataType data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GPUData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // repeated .DataType data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(i), output);
  }

}

int GPUData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated .DataType data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPUData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GPUData*>(&from));
}

void GPUData::MergeFrom(const GPUData& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void GPUData::CopyFrom(const GPUData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < data_size(); i++) {
    if (!this->data(i).IsInitialized()) return false;
  }
  return true;
}

void GPUData::Swap(GPUData* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GPUData::GetTypeName() const {
  return "GPUData";
}


// ===================================================================

#ifndef _MSC_VER
const int SensorsData::kMbDataFieldNumber;
const int SensorsData::kCpuDataFieldNumber;
const int SensorsData::kRamDataFieldNumber;
const int SensorsData::kDiskDataFieldNumber;
const int SensorsData::kGpuDataFieldNumber;
#endif  // !_MSC_VER

SensorsData::SensorsData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SensorsData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  mbdata_ = const_cast< ::MotherboardData*>(
      ::MotherboardData::internal_default_instance());
#else
  mbdata_ = const_cast< ::MotherboardData*>(&::MotherboardData::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  cpudata_ = const_cast< ::CpuData*>(
      ::CpuData::internal_default_instance());
#else
  cpudata_ = const_cast< ::CpuData*>(&::CpuData::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ramdata_ = const_cast< ::RAMData*>(
      ::RAMData::internal_default_instance());
#else
  ramdata_ = const_cast< ::RAMData*>(&::RAMData::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  diskdata_ = const_cast< ::DiskData*>(
      ::DiskData::internal_default_instance());
#else
  diskdata_ = const_cast< ::DiskData*>(&::DiskData::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  gpudata_ = const_cast< ::GPUData*>(
      ::GPUData::internal_default_instance());
#else
  gpudata_ = const_cast< ::GPUData*>(&::GPUData::default_instance());
#endif
}

SensorsData::SensorsData(const SensorsData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SensorsData::SharedCtor() {
  _cached_size_ = 0;
  mbdata_ = NULL;
  cpudata_ = NULL;
  ramdata_ = NULL;
  diskdata_ = NULL;
  gpudata_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SensorsData::~SensorsData() {
  SharedDtor();
}

void SensorsData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete mbdata_;
    delete cpudata_;
    delete ramdata_;
    delete diskdata_;
    delete gpudata_;
  }
}

void SensorsData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SensorsData& SensorsData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_sensors_5fdata_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_sensors_5fdata_2eproto();
#endif
  return *default_instance_;
}

SensorsData* SensorsData::default_instance_ = NULL;

SensorsData* SensorsData::New() const {
  return new SensorsData;
}

void SensorsData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mbdata()) {
      if (mbdata_ != NULL) mbdata_->::MotherboardData::Clear();
    }
    if (has_cpudata()) {
      if (cpudata_ != NULL) cpudata_->::CpuData::Clear();
    }
    if (has_ramdata()) {
      if (ramdata_ != NULL) ramdata_->::RAMData::Clear();
    }
    if (has_diskdata()) {
      if (diskdata_ != NULL) diskdata_->::DiskData::Clear();
    }
    if (has_gpudata()) {
      if (gpudata_ != NULL) gpudata_->::GPUData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SensorsData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MotherboardData mbData = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mbdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cpuData;
        break;
      }

      // optional .CpuData cpuData = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cpuData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cpudata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ramData;
        break;
      }

      // optional .RAMData ramData = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ramData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ramdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_diskData;
        break;
      }

      // optional .DiskData diskData = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_diskData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_diskdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_gpuData;
        break;
      }

      // optional .GPUData gpuData = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gpuData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gpudata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SensorsData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .MotherboardData mbData = 1;
  if (has_mbdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mbdata(), output);
  }

  // optional .CpuData cpuData = 2;
  if (has_cpudata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->cpudata(), output);
  }

  // optional .RAMData ramData = 3;
  if (has_ramdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->ramdata(), output);
  }

  // optional .DiskData diskData = 4;
  if (has_diskdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->diskdata(), output);
  }

  // optional .GPUData gpuData = 5;
  if (has_gpudata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->gpudata(), output);
  }

}

int SensorsData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MotherboardData mbData = 1;
    if (has_mbdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mbdata());
    }

    // optional .CpuData cpuData = 2;
    if (has_cpudata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cpudata());
    }

    // optional .RAMData ramData = 3;
    if (has_ramdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ramdata());
    }

    // optional .DiskData diskData = 4;
    if (has_diskdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->diskdata());
    }

    // optional .GPUData gpuData = 5;
    if (has_gpudata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gpudata());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SensorsData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SensorsData*>(&from));
}

void SensorsData::MergeFrom(const SensorsData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mbdata()) {
      mutable_mbdata()->::MotherboardData::MergeFrom(from.mbdata());
    }
    if (from.has_cpudata()) {
      mutable_cpudata()->::CpuData::MergeFrom(from.cpudata());
    }
    if (from.has_ramdata()) {
      mutable_ramdata()->::RAMData::MergeFrom(from.ramdata());
    }
    if (from.has_diskdata()) {
      mutable_diskdata()->::DiskData::MergeFrom(from.diskdata());
    }
    if (from.has_gpudata()) {
      mutable_gpudata()->::GPUData::MergeFrom(from.gpudata());
    }
  }
}

void SensorsData::CopyFrom(const SensorsData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorsData::IsInitialized() const {

  if (has_mbdata()) {
    if (!this->mbdata().IsInitialized()) return false;
  }
  if (has_cpudata()) {
    if (!this->cpudata().IsInitialized()) return false;
  }
  if (has_ramdata()) {
    if (!this->ramdata().IsInitialized()) return false;
  }
  if (has_diskdata()) {
    if (!this->diskdata().IsInitialized()) return false;
  }
  if (has_gpudata()) {
    if (!this->gpudata().IsInitialized()) return false;
  }
  return true;
}

void SensorsData::Swap(SensorsData* other) {
  if (other != this) {
    std::swap(mbdata_, other->mbdata_);
    std::swap(cpudata_, other->cpudata_);
    std::swap(ramdata_, other->ramdata_);
    std::swap(diskdata_, other->diskdata_);
    std::swap(gpudata_, other->gpudata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SensorsData::GetTypeName() const {
  return "SensorsData";
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
